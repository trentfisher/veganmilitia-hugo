---
author: trent
comments: false
date: 2015-04-23 10:54:46+00:00
layout: post
slug: pick-a-different-two
title: Pick a Different Two
wordpress_id: 695
categories:
- programming
tags:
- bloat
- computer
- moore's law
- software
- software engineering
- software quality
- wirth's law
---

There's an old saying that I first heard a couple of decades ago:


<blockquote>Good. Fast. Cheap. Pick two.</blockquote>


I was listening to an NPR story about [Moore's Law](http://en.wikipedia.org/wiki/Moore%27s_law). At first I was thinking that it gave us computers that are "fast" and "cheap".  But we never got the "fast".  The workstation on my desk 25 years ago was just as fast as the one I'm sitting at now.  Ah, but that old Sun 3/50 didn't have to do nearly as much as my current workstation, which is true.  That old workstation didn't have color, virtual desktops, animated 3d icons, streaming audio and video, bloated web and email programs, etc.  But somehow I got my work done just as quickly.  What's happening here is another law is cancelling out the "fast" part of Moore's Law:   [Wirth's Law](http://en.wikipedia.org/wiki/Wirth%27s_law).  That law basically says that software is getting slower faster than hardware is getting faster.

Case in point:  25 years ago, when I fired up Emacs (which served as my text editor, mail and usenet reader, and web browser), the 4 megs of virtual memory it used had a noticeable impact on other users.  Nowadays Emacs is a lightweight.  Right now my email client (Thunderbird) is taking up 1.2 gigs of virtual memory!

Moore, himself, acknowledged that his law has its limits, and some people place that 10 years in the future.  Thus far, Moore's Law has managed to just barely keep up with Wirth's law.  So what happens when the latter tops out?  I seriously doubt the latter has any limits, as I have yet to see a limit on human wastefulness and incompetence.

I guess we'll need to go back to the trinity listed above.  Maybe we need to start doing something toward "good": stop adding new bells and whistles and go back and fix bugs, make software more reliable and more informative when something does fail, and generally reduce all the frustration that everyone feels when using computers.  In other words, do the opposite of what we've been doing.  It's a massive challenge, and, by and large, unfamiliar, virgin territory.

I know this is probably another one of my utopian dreams, and will probably never happen, but it would be nice if, for once, I could encounter someone using a computer and not feel the urge to apologize on behalf of my profession.
